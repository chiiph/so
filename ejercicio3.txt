El sistema de archivos proc contiene una jerarquia de archivos que representan el estado actual del kernel y sus estructuras de datos.
Este tipo de sistema de archivos es denominado sistema de archivos virtual.
Dentro del directorio /proc se puede encontrar informacion detallada del hardware del sistema y de los procesos que estan ejecutandose actualmente.
Este contenido no se guarda en ningun dispositivo fisico sino que se construye dinamicamente cada vez que se solicita al kernel que lo muestre o cuando queremos visualizar el contenido de sus archivos o directorios. Es por esto que estos datos no existen una vez que el equipo se apaga.


Creacion de Procesos
1. fork()
   pid_t fork(void);
   Crea un nuevo proceso duplicando el proceso invocador, referido como proceso padre. El nuevo proceso, referido como proceso hijo, es un duplicado exacto del proceso padre, exceptuando, entre otras, el process ID, el parent process ID, locks de memoria del padre, etc.

2. clone()
   int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );
   Crea un nuevo proceso, de manera similar a fork(). A diferencia de fork(), esta llamada permite al proceso hijo compartir parte de su contexto de ejecucion con el proceso padre, como el espacio de memoria, tabla de descriptores de archivos y tabla de manejadores de señales.

Manipulacion de Procesos
1. signal()
   sighandler_t signal(int signum, sighandler_t handler);
   Establece la disposicion de la señal signum al controlador handler, que puede ser SIG_IGN (ignora la señal), SIG_DFL (realiza la accion default asociada con la señal), o la direccion de una funcion definida por el programador (un manejador de señales).


Las diferencias que fork() realiza lo explicado en el inciso anterior y la familia de funciones exec() reemplaza la imagen del proceso actual por una nueva imagen de proceso.
Hay una gran variedad de funciones:
   int execl(const char *path, const char *arg, ...);
   int execlp(const char *file, const char *arg, ...);
   int execle(const char *path, const char *arg, ..., char * const envp[]);
   int execv(const char *path, char *const argv[]);
   int execvp(const char *file, char *const argv[]);
El primer argumento de estas funciones es la ruta al archivo que va a ser cargado en memoria y ejecutado, el resto varia de funcion a funcion.
