\documentclass[a4paper,oneside]{report}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{gmverb}
\usepackage[colorlinks=true,urlcolor=black,linkcolor=black]{hyperref}%
\usepackage{listings}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\lstset{language=Java,
frame=single,
basicstyle=\footnotesize,
tabsize=3,
showtabs=false,
showspaces=false,
showstringspaces=false}

\lstset{breaklines}

\title{Sistemas Operativos\\Proyecto 1}

\author{Fernando Sisul (LU: 81236)\and Tomás Touceda (LU: 84024)}

\date{29 de Octubre de 2010}

\begin{document}
\lstset{frame=single}
\maketitle

\tableofcontents

\chapter{Preguntas te\'oricas}
\section{Windows}
	\subsection{Creaci\'on de procesos}
	
	Los procesos en Windows se crean utilizando la funci\'on CreateProcess, a esta se le pasa en los par\'ametros el nombre del binario a ejecutar en el nuevo proceso junto con diferentes flags para especificar distintas caracter\'isticas del mismo, como atributos del proceso, atributos de los hilos que crea el proceso, el entorno del proceso, y el directorio actual donde se encontrar\'a el proceso. La llamada devuelve en el \'ultimo par\'ametro un puntero a una estructura que contiene informaci\'on del proceso creado, y retorna cero si falla, o un n\'umero distinto de cero en caso contrario.
	
	La diferencia m\'as grande con la creaci\'on de procesos en sistemas UNIX es que en Windows se utiliza una funci\'on wrapper de las system calls espec\'ificas (CreateProcess) y en sistemas UNIX se deben ejecutar una serie definida de llamadas al sistema. Esta diferencia hace que la creaci\'on de procesos en Windows sea transparente a cualquier cambio en la definici\'on de las system calls que suceda entre versiones del sistema operativo.
	
	\subsection{Visualizaci\'on de procesos}
	
	Los procesos en los sistemas Windows se pueden visualizar utilizando el Administrador de tareas que provee el sistema, este se activa con las teclas Ctrl+Alt+Del, y permite manipular de forma b\'asica todos los procesos que se encuentren ejecut\'andose al momento en que se lanza el Administrador de tareas.
	
	\subsection{Sysinternals Process Monitor}
	
	La aplicaci\'on Process Monitor es una herramienta de monitoreo avanzada para Windows que muestra en tiempo real la actividad del sistema de archivos, el registro del sistema y de los procesos e hilos en ejecuci\'on. Esta herramienta provee funcionalidades para visualizar informaci\'on de procesos, los stacks de cada hilo, realizar logs en archivos.
	
	\subsection{Sysinternals Process Explorer}
	
	Process Explorer muestra informaci\'on acerca de los recursos y bibliotecas din\'amicas que utilizan los distintos procesos en ejecuci\'on, adem\'as tambi\'en muestra los archivos que cada proceso ha abierto.
	
\section{Linux}
	\subsection{Directorio /proc}
	\subsection{Creaci\'on y manipulaci\'on de procesos}
	\subsection{System calls fork y exec}
\chapter{Algoritmos}
\section{Consideraciones iniciales}
	
	Todos los ejercicios se compilan con un mismo Makefile, para compilar alg\'un ejercicio en particular se deber\'an utilizar comandos del estilo ``make ejercicio4A'', como se especificar\'a en cada ejercicio particular.
	
	Para compilar todos los ejercicios se puede utilizar ``make all'' o simplemente ``make''.
	
	Para ``limpiar'' el directorio se puede utilizar el comando ``make clean''.
	
\section{Creaci\'on de procesos}
	\subsection{Ejercicio 4A}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio4A''.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio4A''.
		
		La aplicaci\'on escribe dentro de un archivo llamado ``output\_ejercicio4A'', en \'el cada proceso escribe un mensaje identific\'andose a s\'i mismo.
		
		El orden de finalizaci\'on de cada proceso es completamente aleatorio, ya que en el c\'odigo no se utiliza expl\'icitamente ninguna funci\'on para que un proceso espere a otro.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
Inicializar mutex en 1;
fork();
if(es_hijo) {
	Escribir en el archivo la identidad del primer hijo
} else {
	fork();
	if(es_segundo_hijo)
		Escribir en el archivo la identidad del segundo hijo
	else
		Escribir en el archivo la identidad del padre
}
		\end{lstlisting}
\subsection{Ejercicio 4B}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio4B''.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio4B''.
		
		El orden de finalizaci\'on de cada proceso es completamente aleatorio, ya que en el c\'odigo no se utiliza expl\'icitamente ninguna funci\'on para que un proceso espere a otro.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
		
		\end{lstlisting}
		
	\subsection{Ejercicio 4C}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio4C''. 
		
		En este caso no solo se genera un ejecutable llamado ejercicio4C, sino que tambi\'en se genera uno llamado ``job4c'' que ser\'a utilizado por el primero y no deber\'a ser llamado expl\'icitamente.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio4C''.
		
		La aplicaci\'on escribe dentro de un archivo llamado ``salida.txt'', en el que se operar\'a como se especific\'o en el enunciado del ejercicio.
		
		El orden de finalizaci\'on de cada proceso hijo es completamente aleatorio, pero el proceso padre, al utilizar la funci\'on wait, espera a que terminen sus hijos antes de finalizar.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
	
		\end{lstlisting}
	\subsection{Ejercicio 5A}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio5A''.
		
		ACLARACI\'ON: Como ya se charl\'o con ayudantes de la c\'atedra, si bien el c\'odigo imprime 10000 lineas con cada letra, como se especifica, por alguna raz\'on que el personal de c\'atedra tampoco supo responder, algunas letras se imprimen un n\'umero arbitrario m\'as de veces.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio5A''.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
void main() {
	Crear los 5 threads para que utilicen la funcion "thread()";
	fork();
	if(es_proceso_hijo)
		Imprimir un mensaje indicando la creacion existosa;
	else
		Esperar a que terminen los threads;
}

void thread(letra) {
	Imprimir 10000 veces letra;
}
		\end{lstlisting}
	\subsection{Ejercicio 5B}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio5B''.
		
		Se generan los binarios: ejercicio5B1, ejercicio5B2, ejercicio5B3, que corresponden a cada inciso del ejercicio.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio5B1'', o ``./ejercicio5B2'', ``./ejercicio5B3''.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}

		\end{lstlisting}
	\subsection{Ejercicio 6A}
		
		\subsubsection{shmget}
			
			\begin{lstlisting}
			int shmget(key_t key, size_t size, int shmflg);
			\end{lstlisting}
			
			Crea un nuevo segmento de memoria compartida con la key y el tama\~no que se especifica por par\'ametro.
			
		\subsubsection{shmat}
			
			\begin{lstlisting}
			void *shmat(int shmid, const void *shmaddr, int shmflg);
			\end{lstlisting}
			
			Se enlaza al segmento de memoria compartida identificado por el shmid que se pasa por par\'ametro.
			
		\subsubsection{shmdt}
			
			\begin{lstlisting}
			int shmdt(const void *shmaddr);
			\end{lstlisting}
			
			Desenlaza el segmento de memoria compartida ubicado en la direcci\'on especificada en el par\'ametro shmaddr.
		
	\subsection{Ejercicio 6B}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio6B''.
		
		Se generan los binarios: ejercicio6B y ejercicio6B\_2.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio6B'', y luego en otra instancia de la consola en mismo directorio ``./ejercicio6B\_2''. No importa el orden en que se ejecuten, ejercicio6B escribe primero un mensaje y luego espera la respuesta, y ejercicio6B\_2 primero lee un mensaje y luego escribe la respuesta. Este comportamiento se realiza infinitas veces.
		
		Para comprobar que el env\'io de mensajes se realiza correctamente estos poseen un id aleatorio para identificarlos. Por otro lado, para facilitar la lectura del output por pantalla, se realizan sleeps entre cada env\'io de mensaje.
		
		\subsubsection{Algoritmo}
		
		NOTA: Como ambos programas funcionan de la misma forma, simplemente se invierte el comportamiento inicial en el env\'io de mensajes, solo se presenta el algoritmo para ejercicio6B.c, y simplemente invirtiendo el orden en que se envia y reciben mensajes se puede obtener el algoritmo de ejercicio6B\_2.
		
		\begin{lstlisting}
Se crea el segmento de memoria compartida para los semaforos utilizados o
se enlaza al mismo si ya esta creado;

Si fue creado, se inicializan los semaforos;

Se crea el segmento de memoria compartida para el buffer de mensajes o
se enlaza al mismo si ya esta creado;

while(1) {
	id = numero random;
	Se espera a que el otro proceso haya leido el mensaje enviado;
	Se envia el mensaje con el id aleatorio;
	Se espera a que el otro proceso responda el mensaje;
	Se lee la respuesta;
}
		\end{lstlisting}
	\subsection{Ejercicio 6C}
	\subsection{Ejercicio 6D}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio6D''.
		
		Se generan los binarios: ejercicio6D1 y ejercicio6D2.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio6D1'', y luego en otra instancia de la consola en mismo directorio ``./ejercicio6D2''. No importa el orden en que se ejecuten, cada binario se encarga de la sincronizaci\'on completa.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
		
		\end{lstlisting}
	\subsection{Ejercicio 6E1}
		\subsubsection{Compilaci\'on}
		
		Se puede compilar este ejercicio en particular con el comando ``make ejercicio6E1''.
		
		Se generan los binarios: ejercicio6E1\_productor y ejercicio6E1\_consumidor.
		
		\subsubsection{Modo de uso}
		
		Dentro del directorio donde se compil\'o el ejercicio, para ejecutarlo se podr\'a hacerlo con el comando ``./ejercicio6E1\_productor'', y luego ``./ejercicio6E1\_consumidor''. El orden es indistinto, ya que la sincrionizaci\'on se encargar\'a de mantener el comportamiento de las aplicaciones consistente.
		
		NOTA: Dado que se utiliza memoria compartida, y el manejo del buffer de mensajes se realiza en forma de pila para facilitar el consumo de mensajes y la producci\'on.
		
		\subsubsection{Algoritmo}
		\begin{lstlisting}
productor() {
	Se crea el segmento de memoria compartida para los semaforos utilizados o
	se enlaza al mismo si ya esta creado;

	Si fue creado, se inicializan los semaforos;

	Se crea el segmento de memoria compartida para el buffer de mensajes o
	se enlaza al mismo si ya esta creado;

	while(1) {
		id = numero random;
		Se espera a que haya un lugar vacio para producir;
		Se produce un mensaje con id aleatorio;
		Se avisa que hay un nuevo mensaje producido;
	}
}

consumidor() {
	Se crea el segmento de memoria compartida para los semaforos utilizados o
	se enlaza al mismo si ya esta creado;

	Si fue creado, se inicializan los semaforos;

	Se crea el segmento de memoria compartida para el buffer de mensajes o
	se enlaza al mismo si ya esta creado;

	while(1) {
		Se espera a que haya un mensaje para consumir;
		Se consume el mensaje;
		Se avisa que esta ese lugar vacio;
	}
}
		\end{lstlisting}
\end{document}